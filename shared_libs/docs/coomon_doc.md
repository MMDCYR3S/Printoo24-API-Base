<!DOCTYPE html><html lang="fa" dir="rtl"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>مستند فنی لایه Common</title><style>:root{--bg-color:#1a1b26;--fg-color:#c0caf5;--card-bg:#24283b;--border-color:#414868;--accent-color:#7aa2f7;--highlight-bg:#bb9af7;--highlight-fg:#1a1b26;--green:#9ece6a;--yellow:#e0af68;--red:#f7768e;--orange:#ff9e64;}@font-face{font-family:'Vazirmatn';src:url('https://cdn.jsdelivr.net/gh/rastikerdar/vazirmatn@v33.003/Vazirmatn-font-face.css');font-weight:100 900;font-display:swap;}body{background-color:var(--bg-color);color:var(--fg-color);font-family:'Vazirmatn',system-ui,sans-serif;line-height:1.8;margin:0;padding:0;font-size:16px;}.container{max-width:950px;margin:2rem auto;padding:1rem 2rem;background-color:var(--bg-color);}h1,h2,h3{color:var(--accent-color);font-weight:600;border-bottom:1px solid var(--border-color);padding-bottom:.5rem;}h1{text-align:center;font-size:2.4rem;border:none;}h2{font-size:1.8rem;margin-top:2.5rem;}h3{font-size:1.4rem;color:var(--green);}ul{list-style:none;padding-right:20px;}li{position:relative;padding-right:25px;margin-bottom:.6rem;}li::before{content:"»";position:absolute;right:0;color:var(--accent-color);}pre{background-color:var(--card-bg);border:1px solid var(--border-color);padding:1rem;border-radius:8px;overflow-x:auto;font-size:.9rem;direction:ltr;}.key{color:var(--yellow);font-weight:bold;}.note{background-color:rgba(122,162,247,.1);border-right:4px solid var(--accent-color);padding:1rem 1.5rem;margin:1.5rem 0;border-radius:6px;}.flow{text-align:center;margin:2rem 0;}.flow span{display:inline-block;padding:.5rem 1rem;margin:.3rem;border-radius:6px;font-weight:600;}.api{background-color:rgba(122,162,247,0.2);color:var(--accent-color);}.service{background-color:rgba(158,206,106,0.15);color:var(--green);}.repo{background-color:rgba(224,175,104,0.18);color:var(--yellow);}.db{background-color:rgba(247,118,142,0.18);color:var(--red);}.arrow{color:var(--fg-color);font-size:1.4rem;vertical-align:middle;}footer{text-align:center;margin-top:3rem;padding-top:1rem;border-top:1px solid var(--border-color);color:#a9b1d6;}</style></head><body><div class="container"><h1>مستند فنی لایه Common</h1><p style="text-align:center;color:#a9b1d6">الگوی معماری تمیز در زیربخش‌های مشترک سیستم</p><section><h2>مقدمه</h2><p>پوشه <code>common</code> یکی از کلیدی‌ترین بخش‌های ساختار پروژه است و هدف آن ارائه سرویس‌ها و رابط‌های مستقل از اپلیکیشن‌های خاص (مانند admin یا customer) است. این ساختار تضمین می‌کند منطق‌های تکراری مثل کار با دیتابیس، کش، ایمیل و داده‌های دامنه‌ای در یک لایه مرکزی مدیریت شوند.</p><div class="flow"><span class="api">API Layer</span><span class="arrow">→</span><span class="service">Service Layer</span><span class="arrow">→</span><span class="repo">Repository Layer</span><span class="arrow">→</span><span class="db">Database</span></div><p>تمامی فایل‌های این مسیر طوری طراحی شده‌اند که باعث ایجاد <strong>ایزوله‌سازی منطقی</strong> بین core models و اپلیکیشن‌های مصرف‌کننده شوند.</p></section><section><h2>۱. فایل repositories.py — پایه معماری Repository Pattern</h2><p><strong>Repository</strong> لایه‌ای بین مدل و سرویس است که وظیفه دارد تمام تعاملات دیتابیسی را در خود متمرکز کند. در واقع، این لایه رابطی است بین ORM و منطق تجاری سیستم.</p><div class="note">هدف اصلی: جلوگیری از تکرار کوئری‌ها و امکان تست‌پذیری بالای منطق داده.</div><ul><li><span class="key">کلاس IRepository:</span> یک کلاس جنریک پایه است که برای هر مدل جنگو می‌تواند استفاده شود.</li><li>با استفاده از <span class="key">TypeVar</span> و <span class="key">Generic[T]</span>، این کلاس از نوع مدل وراثت می‌گیرد و خروجی هر متد کاملاً type-safe است.</li><li>تمام متدهای CRUD (Create، Read، Update، Delete) و متدهای کمکی مثل <span class="key">exists</span> و <span class="key">filter</span> در این لایه پیاده‌سازی شده‌اند.</li></ul><pre><code>repo = IRepository(Product)
product = repo.get_by_id(5)  # واکشی محصول
repo.update(product, {"price": 250000})
repo.delete(product)</code></pre></section><section><h2>۲. پوشه cache/ — سرویس CacheService</h2><p>این سرویس یک wrapper تمیز روی سیستم کش جنگو است تا وابستگی مستقیم بین ماژول‌ها و <code>django.core.cache</code> از بین برود.</p><ul><li><span class="key">set(key, value, timeout)</span>: ذخیره داده‌ها در کش.</li><li><span class="key">get(key, default)</span>: بازیابی داده با fallback پیش‌فرض.</li><li><span class="key">delete(key)</span>: حذف کلید خاص از کش.</li></ul><div class="note"><strong>از دید بک‌اند:</strong> در سرویس‌هایی مثل Catalog می‌توان برای ذخیره محصولات پربازدید استفاده کرد.<br><strong>از دید فرانت‌اند:</strong> این باعث پاسخ سریع‌تر APIها برای داده‌های ثابت می‌شود (Caching Layer بین Front و DB).</div><pre><code>cache_service = CacheService()
cache_service.set("popular_products", data, timeout=300)
products = cache_service.get("popular_products")</code></pre></section><section><h2>۳. پوشه email/ — سرویس EmailService</h2><p>ارسال ایمیل هسته‌ای از تعامل کاربر در تمام سیستم‌هاست (مانند تایید حساب یا اعلان سفارش). این سرویس ساختار <strong>Template-based Email Rendering</strong> را پیاده می‌کند.</p><ul><li>متد <span class="key">_send_email</span> همزمان نسخه HTML و متن ساده ایمیل را تولید می‌کند.</li><li>از متد <span class="key">render_to_string</span> برای تزریق داده‌ها در تمپلیت استفاده می‌شود.</li><li>اگر ارسال شکست بخورد، با لاگ شناور خطا ثبت می‌شود (عدم توقف جریان کاری).</li></ul><div class="note">مزیت: اگر در آینده سیستم پیامک، اعلان یا Push اضافه شود، ساختار موجود برای جایگزینی Email با هر انتقالی قابل استفاده است.</div><pre><code>email_service = EmailService()
email_service._send_email(
   subject="تایید حساب کاربری",
   template_name="emails/account_verify.html",
   context={"username": "امین"},
   from_email="no-reply@site.com",
   to_email="user@example.com"
)</code></pre></section><section><h2>۴. پوشه product/ — سرویس‌ها و ریپازیتوری محصولات</h2><h3>۴.۱ ProductRepository</h3><p>این ریپازیتوری تعامل هوشمند و بهینه با داده‌های محصولات را مدیریت می‌کند. طراحی آن براساس جلوگیری از N+1 Query و افزایش Performance صفحات Product Detail است.</p><ul><li>از <span class="key">select_related</span> برای روابط ForeignKey بهره می‌برد.</li><li>از <span class="key">prefetch_related</span> برای داده‌های many-to-many مانند تصاویر، متریال و سایز استفاده می‌کند.</li><li>تمام داده‌های مکمل در یک Query بهینه واکشی می‌شوند تا کاربر در فرانت بدون تأخیر زیاد به همه دیتا دسترسی یابد.</li></ul><pre><code>repo = ProductRepository()
product = repo.get_product_detail_by_slug("poster-matte")
print(product.product_material.all())</code></pre><h3>۴.۲ ProductService</h3><p>این لایه رابط تمیزی بین API و Repository است. بدین معنا که API دیگر مستقیم از ORM درخواست نمی‌گیرد بلکه با یک <strong>Service Layer</strong> صحبت می‌کند.</p><ul><li><span class="key">get_all_active_products</span>: دریافت تمام محصولات فعال برای صفحه اصلی فروشگاه.</li><li><span class="key">get_product_detail_by_slug</span>: تابع بهینه برای صفحه جزئیات محصول.</li></ul><div class="note">برای توسعه‌دهندگان front: مستقیماً به این لایه نیاز ندارید، اما هر بار که endpoint /products را صدا می‌زنید، داده‌ها از طریق این سرویس مدیریت می‌شوند تا قواعد تجاری (business rules) حفظ شوند.</div></section><section><h2>۵. پوشه users/ — سرویس‌ها و ریپازیتوری کاربران</h2><h3>۵.۱ UserRepository</h3><p>این کلاس همان الگوی IRepository را برای مدل User پیاده کرده اما با متدهای سفارشی مانند <code>get_by_email</code>، <code>get_by_username</code> و <code>save</code> برای نیازهای خاص.</p><h3>۵.۲ UserService</h3><ul><li>این لایه منطق‌های سطح بالای حساب کاربر را مدیریت می‌کند: ایجاد کاربر، تأیید حساب، تغییر رمز عبور.</li><li>کاملاً مستقل از نحوه نمایش (Admin یا Customer) بوده و فقط بر اساس داده خام کار می‌کند.</li></ul><div class="note">ویژگی کلیدی: <strong>Dependency Injection</strong> — ریپازیتوری از بیرون تزریق می‌شود، بنابراین می‌توان Mock repository ایجاد کرد تا تست واحد ساده‌تر شود.</div><pre><code>repo = UserRepository()
service = UserService(repo)
user = service.create_user({"username": "arashk", "email":"a@x.com", "password":"1234"})
service.set_user_as_verified(user)</code></pre></section><section><h2>۶. فلسفه طراحی: تمیزی، توسعه‌پذیری، تست‌پذیری</h2><p>ساختار common به گونه‌ای طراحی شده که هر Feature جدید را بتوان بدون تغییر در سایر بخش‌ها افزود. مثلاً در صورت نیاز به سیستم Cache سطح سرویس، کافی است در Service تابعی اضافه کنیم که قبل از واکشی محصول، CacheService را بررسی کند — بدون تغییر در Repository یا View.</p><div class="note">Frontend Devs می‌توانند به APIهایی اعتماد کنند که خروجی‌شان با قواعد ثابت سرویس‌ها کنترل می‌شود. Backend Devs می‌توانند سریعاً یک mock repo تزریق کرده و منطق را جداگانه تست کنند.</div></section></div><footer><p>مستند فنی تولید شده در تاریخ ۱۴۰۴/۰۸/۲۴</p></footer></body></html>
