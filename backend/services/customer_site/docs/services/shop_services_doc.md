<!DOCTYPE html><html lang="fa" dir="rtl"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>مستند فنی سرویس‌های Shop</title><style>:root{--bg-color:#0f172a;--fg-color:#e2e8f0;--card-bg:#1e293b;--border-color:#334155;--accent-color:#38bdf8;--highlight-bg:#818cf8;--code-bg:#020617;--green:#4ade80;--yellow:#facc15;--red:#f87171;--purple:#c084fc;--orange:#fb923c;}@font-face{font-family:'Vazirmatn';src:url('https://cdn.jsdelivr.net/gh/rastikerdar/vazirmatn@v33.003/Vazirmatn-font-face.css');font-weight:100 900;font-display:swap;}body{background-color:var(--bg-color);color:var(--fg-color);font-family:'Vazirmatn',-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto",sans-serif;line-height:1.8;margin:0;padding:0;font-size:16px;}.container{max-width:980px;margin:2rem auto;padding:1rem 2rem;}header{text-align:center;margin-bottom:3rem;padding-bottom:2rem;border-bottom:1px solid var(--border-color);}h1{font-size:2.4rem;color:var(--accent-color);margin-bottom:0.5rem;}h2{font-size:1.8rem;color:var(--fg-color);border-bottom:2px solid var(--border-color);padding-bottom:0.75rem;margin-top:3rem;display:flex;align-items:center;gap:0.5rem;}h3{font-size:1.4rem;color:var(--purple);margin-top:2rem;}pre{background-color:var(--code-bg);border:1px solid var(--border-color);border-radius:8px;padding:1.2rem;overflow-x:auto;font-family:'Fira Code','Consolas',monospace;font-size:0.9rem;direction:ltr;text-align:left;margin:1rem 0;}.note{background-color:rgba(56,189,248,0.1);border-right:4px solid var(--accent-color);padding:1rem 1.5rem;margin:1.5rem 0;border-radius:6px;}.info{background-color:rgba(74,222,128,0.1);border-right:4px solid var(--green);padding:1rem 1.5rem;margin:1.5rem 0;border-radius:6px;}.badge{display:inline-block;padding:0.2rem 0.6rem;border-radius:4px;font-size:0.8rem;font-weight:bold;margin-left:0.5rem;vertical-align:middle;}.badge-app{background:rgba(251,146,60,0.15);color:var(--orange);}.badge-core{background:rgba(192,132,252,0.15);color:var(--purple);}ul{list-style:none;padding:0;}li{position:relative;padding-right:1.5rem;margin-bottom:0.8rem;}li::before{content:"▹";position:absolute;right:0;color:var(--accent-color);font-weight:bold;}code{font-family:inherit;color:var(--yellow);background:rgba(255,255,255,0.05);padding:0.1rem 0.3rem;border-radius:3px;}footer{text-align:center;margin-top:4rem;padding-top:2rem;border-top:1px dashed var(--border-color);color:#64748b;}</style></head><body><div class="container"><header><h1>مستند فنی سرویس‌های Shop</h1><p style="color:#94a3b8">بررسی عمیق لایه اپلیکیشن: لیست، جزئیات و دسته‌بندی هوشمند</p></header><section><h2>۱. معماری سرویس‌گرا در لایه اپلیکیشن</h2><p>در اپلیکیشن `Shop`، ما از الگوی <strong>Service-Layer Pattern</strong> استفاده می‌کنیم تا منطق نمایش (Presentation Logic) را از منطق هسته (Core Domain) جدا کنیم. این سرویس‌ها واسطی بین View و سرویس‌های قدرتمند `shared_libs` هستند.</p><div class="note"><strong>وظیفه اصلی:</strong> دریافت داده خام از `Core`، ساختاردهی نهایی برای فرانت‌اند (مانند ساخت لینک‌ها یا گروه‌بندی آپشن‌ها) و تحویل به Serializer.</div></section><section><h2>۲. سرویس دسته‌بندی <span class="badge badge-app">ShopCategoryService</span></h2><p>این سرویس مسئول ساخت <strong>درختواره دسته‌بندی‌ها (Category Tree)</strong> است. برخلاف یک لیست ساده، این سرویس خروجی JSON تودرتو (Nested) تولید می‌کند و لینک‌های فیلترینگ را به صورت هوشمند می‌سازد.</p><h3>ویژگی‌های کلیدی:</h3><ul><li><strong>تزریق Request:</strong> سرویس `request` را دریافت می‌کند تا بتواند لینک‌های کامل (Absolute URLs) بسازد.</li><li><strong>لینک‌دهی پویا (HATEOAS):</strong> به جای اینکه فرانت‌اند URLها را حدس بزند، سرویس فیلد `links` را تولید می‌کند.</li><li><strong>پرفورمنس بالا:</strong> استفاده از `get_cached_trees` از کتابخانه MPTT برای جلوگیری از صدها کوئری در ساختار درختی.</li></ul><pre><code># خروجی JSON نمونه
{
    "id": 1,
    "name": "کارت ویزیت",
    "slug": "business-card",
    "links": {
        "products_url": "https://api.site.com/v1/shop/products/?category=business-card"
    },
    "children": [...]
}</code></pre></section><section><h2>۳. سرویس جزئیات محصول <span class="badge badge-app">ShopProductDetailService</span></h2><p>این سرویس وظیفه دارد یک محصول پیچیده (دارای سایز، متریال، آپشن و فایل) را به یک ساختار قابل فهم برای صفحه "جزئیات محصول" تبدیل کند.</p><h3>جریان داده (Data Flow):</h3><ol><li>دریافت `slug` محصول از View.</li><li>فراخوانی `ProductDomainService` (در لایه Core) برای گرفتن محصول و آپشن‌های گروه‌بندی شده.</li><li>تجمیع تمام اطلاعات (تصاویر، فایل‌های ضمیمه، قیمت‌های متریال) در یک دیکشنری واحد.</li><li>تحویل به `ProductDetailSerializer`.</li></ol><div class="info"><strong>نکته مهم:</strong> این سرویس هیچ کوئری مستقیمی به دیتابیس نمی‌زند. تمام کوئری‌ها (شامل `prefetch_related`) قبلاً در لایه Repository بهینه شده‌اند.</div></section><section><h2>۴. سرویس لیست محصولات <span class="badge badge-app">ShopProductListService</span></h2><p>ساده‌ترین سرویس که وظیفه تامین داده برای صفحه کاتالوگ (PLP) را دارد.</p><ul><li><strong>ارتباط با Core:</strong> متد `get_base_queryset` را از سرویس دامین صدا می‌زند.</li><li><strong>آماده‌سازی برای فیلتر:</strong> خروجی این سرویس یک `QuerySet` خام است که سپس توسط `ProductFilter` (کلاس فیلترینگ) پردازش می‌شود.</li></ul><pre><code>def get_base_queryset(self):
    return self._product_service.get_all_active_products()</code></pre></section><section><h2>۵. استراتژی فیلترینگ درختی (MPTT Filtering)</h2><p>یکی از چالش‌های بزرگ فروشگاه‌ها، فیلتر کردن محصولات بر اساس دسته‌بندی والد است (مثلاً نمایش تمام "لپ‌تاپ‌ها" وقتی کاربر روی "کالای دیجیتال" کلیک می‌کند). ما این مشکل را در `ProductFilter` حل کرده‌ایم:</p><pre><code>def filter_by_category_hierarchy(self, queryset, name, value):
    # ۱. پیدا کردن دسته والد
    # ۲. پیدا کردن تمام فرزندان با get_descendants
    # ۳. فیلتر کردن محصولات با عملگر IN
    return queryset.filter(category__in=descendants)</code></pre></section></div><footer><p>تیم فنی ShivaTek | مستندسازی لایه سرویس اپلیکیشن (نسخه نهایی)</p></footer></body></html>